def trim: gsub("^\\s+|\\s+$";"");

def jmes:
  [paths(scalars)]
  | map(
      map(. as $name
          | try (tonumber | "[]")
            catch $name)
      | join("."))
  | unique;

def leaves:
  if
    type == "array"
    or type == "object"
  then
    .[] | leaves
  else
    .
  end;

def sse:
  foreach inputs as $line
    ({};  # Initialize the accumulator
     if $line | startswith("event:") then
       { complete: null, part: $line | sub("event:"; "") | {"event": trim}}
     elif $line | startswith("data:") then
       .complete |= null | .part |= {event: (.event // "message"), data: ($line | sub("data:"; ""))}
     elif $line | startswith(":") then
       .
     elif $line == "" then
       {complete: .part}
     else
       .part.data += $line
     end)
  | select(.complete)
  | .complete
  | . as $i
  | if .data
    then .data |= (
      . as $str
      | try fromjson
        catch {json: $str, error:.})
    end;

def openai:
  foreach inputs as $i
  (
    {};
    (
      if $i.tool_calls and ($i.tool_calls | length) then
        if $i.tool_calls[].function.name then
          "tool_name"
        else
          "tool_arg"
        end
      elif ($i.reasoning | not) then
        "response"
      else
        "think"
        end
    ) as $state
    | (
      if $state != .last
      then "\n"
      else ""
      end
    ) as $sep
    | ( if $state == "think" then
          "\u001b[1;34m\($i.reasoning)\u001b[m"
        elif $state == "tool_name" then
          "\u001b[1;33mcalling \u001b[1;35m\($i.tool_calls[].function.name):\u001b[m"
        elif $state == "tool_arg" then
          "\u001b[1;36m\($i.tool_calls[].function.arguments)\u001b[m"
        else
          $i.content
        end
      ) as $c
    | { text: "\($sep)\($c)", last: $state }
  )
  | .text;
